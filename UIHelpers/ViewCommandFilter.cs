using System;
using System.Collections.Generic;
using System.Linq;
using EnvDTE;
using Microsoft.VisualStudio;
using Microsoft.VisualStudio.Language.Intellisense;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell;
using Microsoft.VisualStudio.Text;
using Microsoft.VisualStudio.Text.Editor;
using Microsoft.VisualStudio.Text.Projection;
using Microsoft.VisualStudio.TextManager.Interop;

namespace UIHelpers
{
    /// <summary>
    /// Class responsible for handling tab and back tab key presses to redirect them on Emmet actions.
    /// </summary>
    internal class ViewCommandFilter : IOleCommandTarget
    {
        private const uint TabCmdId = 4;
        private const uint BackTabCmdId = 5;
        private const int ExpandCmdId = 0x100;
        private readonly Dictionary<uint, int> _commandsRequirePostTranslation =
            new Dictionary<uint, int>
                {
                    { 0x100, 0x110 },
                    { 0x101, 0x111 },
                    { 0x103, 0x113 }
                };

        private readonly Guid _emmetCommandsGuid = Guid.Parse("{bea64453-e066-4057-b565-0a36bddd0852}");

        private readonly Guid _filteredGuid = typeof(VSConstants.VSStd2KCmdID).GUID;
        private readonly IOleCommandTarget _nextTarget;
        private readonly ICompletionBroker _completionBroker;
        private readonly EmmetSyntax _syntax;
        private readonly IWpfTextView _view;
        private TabSpanManager _tabSpans;

        internal ViewCommandFilter(
            IWpfTextView view, IVsTextView adapter, ICompletionBroker completionBroker, EmmetSyntax syntax)
        {
            _view = view;
            _completionBroker = completionBroker;
            _syntax = syntax;

            _tabSpans = new TabSpanManager(view);

            adapter.AddCommandFilter(this, out _nextTarget);
        }

        /// <summary>
        /// Queries the object for the status of one or more commands generated by user interface events.
        /// </summary>
        /// <param name="pguidCmdGroup">The GUID of the command group.</param>
        /// <param name="cCmds">The number of commands in <paramref name="prgCmds" />.</param>
        /// <param name="prgCmds">An array of <see cref="T:Microsoft.VisualStudio.OLE.Interop.OLECMD" />
        /// structures that indicate the commands for which the caller needs status information. This method
        /// fills the cmdf member of each structure with values taken from the
        /// <see cref="T:Microsoft.VisualStudio.OLE.Interop.OLECMDF" /> enumeration.</param>
        /// <param name="pCmdText">An <see cref="T:Microsoft.VisualStudio.OLE.Interop.OLECMDTEXT" /> structure
        /// in which to return name and/or status information of a single command. This parameter can be null
        /// to indicate that the caller does not need this information.</param>
        /// <returns>
        /// This method returns S_OK on success.
        /// </returns>
        public int QueryStatus(ref Guid pguidCmdGroup, uint cCmds, OLECMD[] prgCmds, IntPtr pCmdText)
        {
            return _nextTarget.QueryStatus(ref pguidCmdGroup, cCmds, prgCmds, pCmdText);
        }

        /// <summary>
        /// Executes the specified command.
        /// </summary>
        /// <param name="pguidCmdGroup">The GUID of the command group.</param>
        /// <param name="nCmdId">The command ID.</param>
        /// <param name="nCmdexecopt">Ignored.</param>
        /// <param name="pvaIn">The input arguments of the command.</param>
        /// <param name="pvaOut">The output arguments of the command.</param>
        /// <returns>
        /// This method returns S_OK on success.
        /// </returns>
        public int Exec(ref Guid pguidCmdGroup, uint nCmdId, uint nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
        {
            // Handle TAB and BACKTAB events
            if (_filteredGuid == pguidCmdGroup)
            {
                if (nCmdId == TabCmdId &&
                    !_completionBroker.IsCompletionActive(_view) &&
                    (RunEmmetAction(ExpandCmdId) || _tabSpans.MoveToNextEmptySlot()))
                    return 0;
                if (nCmdId == BackTabCmdId &&
                    !_completionBroker.IsCompletionActive(_view) &&
                    _tabSpans.MoveToPreviousEmptySlot())
                    return 0;

                return _nextTarget.Exec(pguidCmdGroup, nCmdId, nCmdexecopt, pvaIn, pvaOut);
            }

            // Post process result of other emmet actions
            if (_emmetCommandsGuid == pguidCmdGroup &&
                EmmetSyntax.Html == _syntax &&
                _commandsRequirePostTranslation.ContainsKey(nCmdId))
            {
                RunEmmetAction(nCmdId);

                return 0;
            }

            return _nextTarget.Exec(pguidCmdGroup, nCmdId, nCmdexecopt, pvaIn, pvaOut);
        }

        private bool RunEmmetAction(uint nCmdId)
        {
            if (ExpandCmdId == nCmdId)
            {
                Span zenExpression = GetText();
                if ((zenExpression.Length == 0) || !IsValidTextBuffer())
                    return false;
            }

            DTE dte = (DTE)Package.GetGlobalService(typeof(DTE));
            int translatedCmdId = _commandsRequirePostTranslation[nCmdId];
            dte.Commands.Raise(_emmetCommandsGuid.ToString("p"), translatedCmdId, null, null);

            _tabSpans.PostProcessSelection();

            return true;
        }

        private Span GetText()
        {
            int position = _view.Caret.Position.BufferPosition.Position;
            if (position >= 0)
            {
                ITextSnapshotLine lineFromPosition =
                    _view.TextBuffer.CurrentSnapshot.GetLineFromPosition(position);
                string str = lineFromPosition.GetText().TrimEnd(new char[0]);
                if ((string.IsNullOrWhiteSpace(str) ||
                    (str.Length < (position - lineFromPosition.Start))) ||
                    ((str.Length + lineFromPosition.Start) > position))
                {
                    return new Span();
                }

                string source = str.Substring(0, position - lineFromPosition.Start).TrimStart(new char[0]);
                if (((source.Length > 0) &&
                    !str.Contains("<")) &&
                    !char.IsWhiteSpace(source.Last()))
                {
                    int index = str.IndexOf(source, StringComparison.InvariantCulture);
                    return new Span(lineFromPosition.Start.Position + index, source.Length);
                }
            }

            return new Span();
        }

        private bool IsValidTextBuffer()
        {
            IProjectionBuffer textBuffer = _view.TextBuffer as IProjectionBuffer;
            if (textBuffer != null)
            {
                SnapshotPoint bufferPosition = _view.Caret.Position.BufferPosition;
                var buffers = from s in textBuffer.SourceBuffers
                              where
                                  (((!s.ContentType.IsOfType("html") && !s.ContentType.IsOfType("inert")) &&
                                    (!s.ContentType.IsOfType("CSharp") &&
                                     !s.ContentType.IsOfType("VisualBasic"))) &&
                                   !s.ContentType.IsOfType("RoslynCSharp")) &&
                                  !s.ContentType.IsOfType("RoslynVisualBasic")
                              select s;
                foreach (ITextBuffer buffer2 in buffers)
                {
                    if (_view.BufferGraph.MapDownToBuffer(bufferPosition,
                                                          PointTrackingMode.Negative,
                                                          buffer2,
                                                          PositionAffinity.Predecessor).HasValue)
                    {
                        return false;
                    }
                }
            }

            return true;
        }
    }
}