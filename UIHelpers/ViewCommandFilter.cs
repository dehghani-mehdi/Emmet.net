using System;
using System.Collections.Generic;
using System.Linq;
using EnvDTE;
using Microsoft.VisualStudio;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell;
using Microsoft.VisualStudio.Text;
using Microsoft.VisualStudio.Text.Editor;
using Microsoft.VisualStudio.Text.Projection;
using Microsoft.VisualStudio.TextManager.Interop;

namespace UIHelpers
{
    /// <summary>
    /// Class responsible for handling tab and back tab key presses to redirect them on Emmet actions.
    /// </summary>
    internal class ViewCommandFilter : IOleCommandTarget
    {
        private const int ExpandCmdId = 0x100;
        private readonly Dictionary<uint, int> _commandsRequirePostTranslation =
            new Dictionary<uint, int>
                {
                    { 0x100, 0x110 },
                    { 0x101, 0x111 }
                };

        private readonly Guid _emmetCommandsGuid = Guid.Parse("{bea64453-e066-4057-b565-0a36bddd0852}");
        private readonly IOleCommandTarget _nextTarget;
        private readonly EmmetSyntax _syntax;
        private readonly IWpfTextView _view;
        private readonly TabSpanManager _tabSpans;

        internal ViewCommandFilter(IWpfTextView view, IVsTextView adapter, EmmetSyntax syntax)
        {
            _view = view;
            _syntax = syntax;

            _tabSpans = new TabSpanManager(view);

            adapter.AddCommandFilter(this, out _nextTarget);
        }

        /// <summary>
        /// Queries the object for the status of one or more commands generated by user interface events.
        /// </summary>
        /// <param name="pguidCmdGroup">The GUID of the command group.</param>
        /// <param name="cCmds">The number of commands in <paramref name="prgCmds" />.</param>
        /// <param name="prgCmds">An array of <see cref="T:Microsoft.VisualStudio.OLE.Interop.OLECMD" />
        /// structures that indicate the commands for which the caller needs status information. This method
        /// fills the cmdf member of each structure with values taken from the
        /// <see cref="T:Microsoft.VisualStudio.OLE.Interop.OLECMDF" /> enumeration.</param>
        /// <param name="pCmdText">An <see cref="T:Microsoft.VisualStudio.OLE.Interop.OLECMDTEXT" /> structure
        /// in which to return name and/or status information of a single command. This parameter can be null
        /// to indicate that the caller does not need this information.</param>
        /// <returns>
        /// This method returns S_OK on success.
        /// </returns>
        public int QueryStatus(ref Guid pguidCmdGroup, uint cCmds, OLECMD[] prgCmds, IntPtr pCmdText)
        {
            if (pguidCmdGroup == _emmetCommandsGuid)
            {
                for (int i = 0; i < cCmds; i++)
                {
                    if (_commandsRequirePostTranslation.ContainsKey(prgCmds[i].cmdID))
                    {
                        prgCmds[i].cmdf = (uint)(OLECMDF.OLECMDF_ENABLED | OLECMDF.OLECMDF_SUPPORTED);
                        return VSConstants.S_OK;
                    }
                }
            }

            return _nextTarget.QueryStatus(ref pguidCmdGroup, cCmds, prgCmds, pCmdText);
        }

        /// <summary>
        /// Executes the specified command.
        /// </summary>
        /// <param name="pguidCmdGroup">The GUID of the command group.</param>
        /// <param name="nCmdId">The command ID.</param>
        /// <param name="nCmdexecopt">Ignored.</param>
        /// <param name="pvaIn">The input arguments of the command.</param>
        /// <param name="pvaOut">The output arguments of the command.</param>
        /// <returns>
        /// This method returns S_OK on success.
        /// </returns>
        public int Exec(ref Guid pguidCmdGroup, uint nCmdId, uint nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
        {
            if (pguidCmdGroup == VSConstants.VSStd2K)
            {
                switch (nCmdId)
                {
                    case (uint)VSConstants.VSStd2KCmdID.TAB:
                        if (EmmetSyntax.Css == _syntax && RunEmmetAction(ExpandCmdId))
                            return VSConstants.S_OK;
                        if (_tabSpans.MoveToNextEmptySlot())
                            return VSConstants.S_OK;
                        break;
                    case (uint)VSConstants.VSStd2KCmdID.BACKTAB:
                        if (_tabSpans.MoveToPreviousEmptySlot())
                            return VSConstants.S_OK;
                        break;
                    case (uint)VSConstants.VSStd2KCmdID.DOWN:
                    case (uint)VSConstants.VSStd97CmdID.Escape:
                    case (uint)VSConstants.VSStd2KCmdID.UP:
                        _tabSpans.Reset();
                        break;
                }

                return _nextTarget.Exec(pguidCmdGroup, nCmdId, nCmdexecopt, pvaIn, pvaOut);
            }

            if (pguidCmdGroup == VSConstants.VSStd2K &&
                nCmdId == (uint)VSConstants.VSStd2KCmdID.ECMD_LEFTCLICK)
                _tabSpans.Reset();

            // Post process result of other emmet actions
            if (_emmetCommandsGuid == pguidCmdGroup &&
                EmmetSyntax.Html == _syntax &&
                _commandsRequirePostTranslation.ContainsKey(nCmdId))
            {
                RunEmmetAction(nCmdId);

                return VSConstants.S_OK;
            }

            return _nextTarget.Exec(pguidCmdGroup, nCmdId, nCmdexecopt, pvaIn, pvaOut);
        }

        private bool RunEmmetAction(uint nCmdId)
        {
            if (ExpandCmdId == nCmdId)
            {
                Span zenExpression = GetText();
                if ((zenExpression.Length == 0) || !IsValidTextBuffer())
                    return false;
            }

            DTE dte = (DTE)Package.GetGlobalService(typeof(DTE));
            int translatedCmdId = _commandsRequirePostTranslation[nCmdId];
            dte.Commands.Raise(_emmetCommandsGuid.ToString("p"), translatedCmdId, null, null);

            _tabSpans.PostProcessSelection();

            return true;
        }

        private Span GetText()
        {
            int position = _view.Caret.Position.BufferPosition.Position;
            if (position >= 0)
            {
                ITextSnapshotLine lineFromPosition =
                    _view.TextBuffer.CurrentSnapshot.GetLineFromPosition(position);
                string str = lineFromPosition.GetText().TrimEnd(new char[0]);
                if ((string.IsNullOrWhiteSpace(str) ||
                    (str.Length < (position - lineFromPosition.Start))) ||
                    ((str.Length + lineFromPosition.Start) > position))
                {
                    return new Span();
                }

                string source = str.Substring(0, position - lineFromPosition.Start).TrimStart(new char[0]);
                if (((source.Length > 0) &&
                    !str.Contains("<")) &&
                    !char.IsWhiteSpace(source.Last()))
                {
                    int index = str.IndexOf(source, StringComparison.InvariantCulture);
                    return new Span(lineFromPosition.Start.Position + index, source.Length);
                }
            }

            return new Span();
        }

        private bool IsValidTextBuffer()
        {
            var projection = _view.TextBuffer as IProjectionBuffer;

            if (projection != null)
            {
                var snapshotPoint = _view.Caret.Position.BufferPosition;

                var buffers = projection.SourceBuffers.Where(
                    s =>
                        !s.ContentType.IsOfType("html")
                        && !s.ContentType.IsOfType("htmlx")
                        && !s.ContentType.IsOfType("inert")
                        && !s.ContentType.IsOfType("CSharp")
                        && !s.ContentType.IsOfType("VisualBasic")
                        && !s.ContentType.IsOfType("RoslynCSharp")
                        && !s.ContentType.IsOfType("RoslynVisualBasic"));


                foreach (ITextBuffer buffer in buffers)
                {
                    SnapshotPoint? point = _view.BufferGraph.MapDownToBuffer(
                        snapshotPoint, PointTrackingMode.Negative, buffer, PositionAffinity.Predecessor);

                    if (point.HasValue)
                    {
                        return false;
                    }
                }
            }

            return true;
        }
    }
}